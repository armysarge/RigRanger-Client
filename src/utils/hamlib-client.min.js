const{EventEmitter:EventEmitter}=require("events"),net=require("net");class HamlibClient extends EventEmitter{constructor(){super(),this.socket=null,this.connected=!1,this.host="",this.port=4532,this.commandQueue=[],this.processing=!1,this.reconnectTimer=null,this.reconnectAttempts=0,this.maxReconnectAttempts=5,this.reconnectDelay=2e3}connect(t,e=4532){return new Promise(((s,n)=>{this.host=t,this.port=e,this.reconnectAttempts=0,this.socket=new net.Socket,this.socket.on("connect",(()=>{this.connected=!0,this.emit("status",{status:"connected",message:`Connected to ${this.host}:${this.port}`}),this.processQueue(),s()})),this.socket.on("data",(t=>{const e=t.toString().trim();this.emit("data",e)})),this.socket.on("error",(t=>{this.emit("status",{status:"error",message:`Connection error: ${t.message}`}),n(t)})),this.socket.on("close",(()=>{this.connected=!1,this.emit("status",{status:"disconnected",message:"Disconnected from server"}),this.attemptReconnect()})),this.emit("status",{status:"connecting",message:`Connecting to ${t}:${e}...`}),this.socket.connect(e,t)}))}attemptReconnect(){this.reconnectTimer&&(clearTimeout(this.reconnectTimer),this.reconnectTimer=null),this.reconnectAttempts<this.maxReconnectAttempts&&(this.reconnectAttempts++,this.emit("status",{status:"reconnecting",message:`Reconnecting (${this.reconnectAttempts}/${this.maxReconnectAttempts})...`,attempt:this.reconnectAttempts,maxAttempts:this.maxReconnectAttempts}),this.reconnectTimer=setTimeout((()=>{this.connect(this.host,this.port).catch((()=>{}))}),this.reconnectDelay))}disconnect(){this.reconnectTimer&&(clearTimeout(this.reconnectTimer),this.reconnectTimer=null),this.socket&&(this.socket.destroy(),this.socket=null),this.connected=!1,this.emit("status",{status:"disconnected",message:"Disconnected from server"})}sendCommand(t){return new Promise(((e,s)=>{if(!this.connected||!this.socket)return void this.commandQueue.push({command:t,resolve:e,reject:s});const n=t.endsWith("\n")?t:t+"\n",o=t=>{const n=t.toString().trim();if(this.socket.removeListener("data",o),n.startsWith("RPRT -")){const t=parseInt(n.split(" ")[1],10),e=new Error(`Command failed with code ${t}`);e.code=t,s(e)}else e(n);this.processQueue()};this.socket.once("data",o),this.socket.write(n)}))}processQueue(){if(this.processing||0===this.commandQueue.length||!this.connected)return;this.processing=!0;const{command:t,resolve:e,reject:s}=this.commandQueue.shift();this.sendCommand(t).then(e).catch(s).finally((()=>{this.processing=!1,this.processQueue()}))}async getInfo(){try{const t=(await this.sendCommand("\\dump_state")).split("\n"),e={model:"",version:"",capabilities:[]};for(const s of t)s.startsWith("Caps dump for model:")?e.model=s.replace("Caps dump for model:","").trim():s.startsWith("Rig version:")?e.version=s.replace("Rig version:","").trim():s.includes("Can ")&&e.capabilities.push(s.trim());return e}catch(t){throw new Error(`Failed to get radio info: ${t.message}`)}}async getFrequency(){try{const t=await this.sendCommand("f");return parseInt(t,10)}catch(t){throw new Error(`Failed to get frequency: ${t.message}`)}}async setFrequency(t){try{return await this.sendCommand(`F ${t}`),!0}catch(t){throw new Error(`Failed to set frequency: ${t.message}`)}}async getMode(){try{const t=await this.sendCommand("m"),[e,s]=t.split("\n");return{mode:e.trim(),passband:parseInt(s,10)}}catch(t){throw new Error(`Failed to get mode: ${t.message}`)}}async setMode(t,e=0){try{return await this.sendCommand(`M ${t} ${e}`),!0}catch(t){throw new Error(`Failed to set mode: ${t.message}`)}}async getPTT(){try{const t=await this.sendCommand("t");return 1===parseInt(t,10)}catch(t){throw new Error(`Failed to get PTT status: ${t.message}`)}}async setPTT(t){try{return await this.sendCommand("T "+(t?1:0)),!0}catch(t){throw new Error(`Failed to set PTT: ${t.message}`)}}async getLevel(t){try{const e=await this.sendCommand(`l ${t}`);return parseFloat(e)}catch(e){throw new Error(`Failed to get level ${t}: ${e.message}`)}}async setLevel(t,e){try{return await this.sendCommand(`L ${t} ${e}`),!0}catch(e){throw new Error(`Failed to set level ${t}: ${e.message}`)}}async getFunction(t){try{const e=await this.sendCommand(`u ${t}`);return 1===parseInt(e,10)}catch(e){throw new Error(`Failed to get function ${t}: ${e.message}`)}}async setFunction(t,e){try{return await this.sendCommand(`U ${t} ${e?1:0}`),!0}catch(e){throw new Error(`Failed to set function ${t}: ${e.message}`)}}}module.exports=HamlibClient;